  <div class="stackedit__html">

<h1 id="grammars-describing-syntax-and-semantics">Grammars: Describing Syntax and Semantics</h1>
<p>Grammars are  used to describe languages, where a language is defined as a collection of strings in our case. Strings are thought of as a collection of so-called terminal symbols in their most basic form. These terminal symbols are lexical tokens generated by lexical analysis, which organizes substrings into tokens of the proper kind and skips over<br>
whitespace.</p>
<ul>
<li>A <em>metalanguage</em> is a language used to define other languages.</li>
<li>A <em>grammar</em> is a metalanguage used to describe the syntax of a<br>
language.</li>
</ul>
<p><strong>Informal</strong>: An informal language is expressed in a natural language<br>
(English).</p>
<p><strong>Formal</strong>: A formal specification is one expressed in a precise<br>
notation.</p>
<p>Informal syntax of some commands in a C-like language:</p>
<p>A while command consists of ‘while’, followed by an expression enclosed in parentheses, followed by a command. A sequential command consists of a sequence of one or more commands, enclosed by ‘{’ and ‘}’.</p>
<h2 id="formal-syntax-using-ebnf-notation">Formal syntax (using EBNF notation)</h2>
<pre class=" language-ebnf"><code class="prism  language-ebnf">     while-command = 'while' '(' expression ')' body= '{' body+ '}
</code></pre>
<h2 id="backus-naur-form-bnf">Backus-Naur Form (BNF)</h2>
<p>BNF (Backus–Naur Form) is a context-free grammar used by programming language developers to establish a language’s syntactic rules. John Backus was a programmer who created a notation to document IAL (an early implementation of Algol).</p>
<p>A stylized form of context-free grammar, also known as the Backus Normal Form, was initially introduced to describe the syntax of Algol 60. These grammars are part of the Chomsky hierarchy and have become a standard tool for defining the syntax of most major programming languages today.</p>
<blockquote>
<p>The Backus Naur Form (BNF) is a notation for expressing grammar.</p>
</blockquote>
<ul>
<li>
<p>The <strong>Terminal symbols</strong>-Each terminal symbol is a symbol that may occur in<br>
a sentence.</p>
</li>
<li>
<p><strong>Nonterminal symbols</strong> -Each nonterminal symbol stands for a phrase that may form part of a sentence</p>
</li>
<li>
<p><strong>Production Rules</strong>-Each production rule specifies how phrases are<br>
composed of terminal symbols and sub-phrases.</p>
</li>
</ul>
<p>Consider the grammar: This grammar defines an unsigned integer.</p>
<pre class=" language-csharp"><code class="prism  language-csharp">Integer<span class="token punctuation">:</span> Digit<span class="token operator">|</span>Integer Digit
Digit<span class="token punctuation">:</span> <span class="token number">0</span><span class="token operator">|</span><span class="token number">1</span><span class="token operator">|</span><span class="token number">2</span><span class="token operator">|</span><span class="token number">3</span><span class="token operator">|</span><span class="token number">4</span><span class="token operator">|</span><span class="token number">5</span><span class="token operator">|</span><span class="token number">6</span><span class="token operator">|</span><span class="token number">7</span><span class="token operator">|</span><span class="token number">8</span><span class="token operator">|</span><span class="token number">9</span>
</code></pre>
<p>We can <em>derive</em> any unsigned integer, like 257, from this grammar.</p>
<p><strong>Derivation for 257 is shown in the below image.</strong></p>
<pre class=" language-csharp"><code class="prism  language-csharp"> Integer<span class="token operator">=</span><span class="token operator">&gt;</span> Integer Digit
        <span class="token operator">=</span><span class="token operator">&gt;</span> Integer Digit Digit
        <span class="token operator">=</span><span class="token operator">&gt;</span> Digit Digit Digit
        <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span> Digit Digit
        <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token number">5</span> Digit
        <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token number">5</span> <span class="token number">7</span>
</code></pre>
<p>This is called a <em>leftmost derivation</em> since, at each step, the leftmost<br>
nonterminal is replaced.</p>
<h2 id="leftmost-derivation">Leftmost derivation</h2>
<blockquote>
<p>A left-most derivation is one in which each step only substitutes the<br>
syntactic variable on the left.</p>
</blockquote>
<h2 id="right-most-derivation">Right-most derivation</h2>
<blockquote>
<p>In the <em>right most</em> derivation, each step replaces the <em>right most</em><br>
syntactic variable.</p>
</blockquote>
<h2 id="extended-backus--naur-form-ebnf">Extended Backus–Naur Form (EBNF)</h2>
<p>EBNF adopted an extension to classical BNF to simplify grammatical rules. Extended Backus–Naur Form (<strong>EBNF</strong>) is a family of metasyntax notations, any of which can be used to express context-free grammar. <strong>EBNF</strong> is used to formally describe a formal language such as a computer programming language.</p>
<ul>
<li>A text-based method for describing syntax in a source language.</li>
<li>Named after John Backus and Peter Naur.</li>
<li>Text-based means a program can also read it.</li>
</ul>
<p>EBNF Uses certain meta-symbols shown in the below image</p>
<p><img src="./chapter-03/desc-ebnf-g.png" alt="Image"></p>
<h2 id="example-1">Example 1</h2>
<p>Let’s consider the following grammar that validates the if statement in the program. As shown below, you can write the grammar for the if statement in EBNF format.</p>
<p><img src="./chapter-03/7af9542e-fe15-4031-adbc-96d6e9e3fbe6_smallRaw.png" alt="Image"></p>
<blockquote>
<p>EBNF FOR IF STATEMENT</p>
</blockquote>
<h2 id="example-2">Example 2</h2>
<p>An expression is a simple expression optionally followed by a relational operator and another simple expression.</p>
<pre class=" language-csharp"><code class="prism  language-csharp">    <span class="token operator">&lt;</span>expression<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token operator">&lt;</span>simple expression<span class="token operator">&gt;</span>
                     <span class="token operator">|</span> <span class="token operator">&lt;</span>simple expression<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>rel op<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>sinple expression<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>rel op<span class="token operator">&gt;</span>    <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token operator">|</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token operator">&lt;</span> <span class="token operator">|</span><span class="token operator">&lt;=</span><span class="token operator">|</span> <span class="token operator">&lt;=</span>
</code></pre>
<h2 id="bnf-vs-ebnf">BNF VS EBNF</h2>
<p>The following table shows how to convert BNF to EBNF</p>
<h2 id="bnf">BNF</h2>
<pre class=" language-csharp"><code class="prism  language-csharp">
<span class="token operator">&lt;</span>expr<span class="token operator">&gt;=</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>expr<span class="token operator">&gt;</span><span class="token operator">+</span><span class="token operator">&lt;</span>term<span class="token operator">&gt;</span>
         <span class="token operator">|</span><span class="token operator">&lt;</span>expr<span class="token operator">&gt;</span><span class="token operator">-</span><span class="token operator">&lt;</span>term<span class="token operator">&gt;</span>
         <span class="token operator">|</span><span class="token operator">&lt;</span>term<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>term<span class="token operator">&gt;=</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>term<span class="token operator">&gt;</span><span class="token operator">*</span><span class="token operator">&lt;</span>factor<span class="token operator">&gt;</span>
        <span class="token operator">|</span> <span class="token operator">&lt;</span>term<span class="token operator">&gt;</span><span class="token operator">/</span><span class="token operator">&lt;</span>factor<span class="token operator">&gt;</span>
        <span class="token operator">|</span> <span class="token operator">&lt;</span>factor<span class="token operator">&gt;</span>

</code></pre>
<h2 id="ebnf">EBNF</h2>
<pre class=" language-csharp"><code class="prism  language-csharp">
<span class="token operator">&lt;</span>expr<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token operator">&lt;</span>term<span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token string">'+'</span><span class="token operator">|</span><span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>term<span class="token operator">&gt;</span> <span class="token punctuation">}</span>
<span class="token operator">&lt;</span>term<span class="token operator">&gt;</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token operator">&lt;</span>factor<span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token string">'*'</span><span class="token operator">|</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>factor<span class="token operator">&gt;</span> <span class="token punctuation">}</span>

</code></pre>
<blockquote>
<p>Where the parentheses group the alternatives in one place.</p>
</blockquote>
<h2 id="what-is-context-free-grammar">What is context-free grammar?</h2>
<p>Context-Free Grammar (CFG) is like a set of rules for building sentences in a made-up language. It tells you what words you can use, how to put them together, and what order they should go in.</p>
<p>For example, let’s say we have context-free grammar for building sentences about animals:</p>
<ul>
<li>A sentence starts with an animal.</li>
<li>An animal can be a “dog”, a “cat”, or a “bird”.</li>
<li>After the animal, there can be a verb like “runs”, “flies”, or “meows”.</li>
<li>Finally, there can be an optional object like “a ball”, “a mouse”, or “in the sky”.</li>
<li></li>
</ul>
<p>Using these rules, we can build sentences like:</p>
<ul>
<li>“A cat meows.”</li>
<li>“A bird flies in the sky.”</li>
<li>“A dog runs after a ball.”</li>
</ul>
<p>So context-free grammar is a way to define a language, by formally specifying its rules and structure.</p>
<div class="alert-info">
</div><p>English is a natural language, which means it has evolved over time and is used to communicate between people. It is not created in accordance with a set of formal rules. A context-free grammar, on the other hand, is a formal way of describing a language, typically an artificial language used in computer science or linguistics. It is a set of rules that define a language’s structure, including how words can be combined to form sentences. While natural languages, such as English, have rules and structures, they are frequently more complex and inconsistent than those found in a context-free grammar. In English, for example, many irregular verbs do not follow the same patterns as regular verbs, whereas in context-free grammar, all rules are typically regular and predictable.</p>

<blockquote>
<p>As per the Wikipedia</p>
</blockquote>
<p>In formal language theory, context-free grammar (CFG) is a formal<br>
grammar whose production rules are of the form.</p>
<pre class=" language-ebnf"><code class="prism  language-ebnf">    A⇒α
</code></pre>
<blockquote>
<p>α is a sequence of the terminal and nonterminal symbols, and A is a nonterminal symbol</p>
</blockquote>
<p>With <strong>A</strong> a single nonterminal symbol, and α a string of terminals and nonterminals (α can be empty). A formal grammar is “context-free” <em><strong>if its production rules can be applied regardless of the context of a nonterminal.</strong></em> <em><strong>No matter which symbols surround it, the single nonterminal on the left-hand side can always be replaced by the right-hand side.</strong></em></p>
<p>Let’s consider the following grammar.</p>
<pre class=" language-csharp"><code class="prism  language-csharp">
    E<span class="token punctuation">:</span> ab
    E<span class="token punctuation">:</span> aEb
</code></pre>
<p>We can have the following derivations:</p>
<pre class=" language-csharp"><code class="prism  language-csharp">    E<span class="token operator">-</span><span class="token operator">&gt;</span> aEB
    aEb<span class="token operator">-</span><span class="token operator">&gt;</span>aaBB
    aEb<span class="token operator">-</span><span class="token operator">&gt;</span>aaEbb<span class="token operator">-</span><span class="token operator">&gt;</span>aaabbb

</code></pre>
<blockquote>
<p>The meaning of the production rule is that <strong>the expression on the right-hand side may replace the non-terminal on the left-hand side</strong></p>
</blockquote>
<h2 id="an-ambiguous-grammar-and-removing-ambiguity">An ambiguous grammar and Removing Ambiguity</h2>
<p>A grammar is ambiguous if its language contains at least one string with two different parse trees.</p>
<pre class=" language-ebnf"><code class="prism  language-ebnf">    expr: INT 
          | expr+ expr 
          | expr* expr ;

</code></pre>
<p>Consider the program:</p>
<pre class=" language-bash"><code class="prism  language-bash">    1 + 4 * 8
</code></pre>
<p>It has two parse trees:</p>
<pre class=" language-mermaid"><svg id="mermaid-svg-6NnKgRXmDZIxV4Ta" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="358.03125" style="max-width: 207.796875px;" viewBox="0 0 207.796875 358.03125"><style>#mermaid-svg-6NnKgRXmDZIxV4Ta{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#000000;}#mermaid-svg-6NnKgRXmDZIxV4Ta .error-icon{fill:#552222;}#mermaid-svg-6NnKgRXmDZIxV4Ta .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-6NnKgRXmDZIxV4Ta .marker{fill:#666;stroke:#666;}#mermaid-svg-6NnKgRXmDZIxV4Ta .marker.cross{stroke:#666;}#mermaid-svg-6NnKgRXmDZIxV4Ta svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-6NnKgRXmDZIxV4Ta .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#000000;}#mermaid-svg-6NnKgRXmDZIxV4Ta .cluster-label text{fill:#333;}#mermaid-svg-6NnKgRXmDZIxV4Ta .cluster-label span{color:#333;}#mermaid-svg-6NnKgRXmDZIxV4Ta .label text,#mermaid-svg-6NnKgRXmDZIxV4Ta span{fill:#000000;color:#000000;}#mermaid-svg-6NnKgRXmDZIxV4Ta .node rect,#mermaid-svg-6NnKgRXmDZIxV4Ta .node circle,#mermaid-svg-6NnKgRXmDZIxV4Ta .node ellipse,#mermaid-svg-6NnKgRXmDZIxV4Ta .node polygon,#mermaid-svg-6NnKgRXmDZIxV4Ta .node path{fill:#eee;stroke:#999;stroke-width:1px;}#mermaid-svg-6NnKgRXmDZIxV4Ta .node .label{text-align:center;}#mermaid-svg-6NnKgRXmDZIxV4Ta .node.clickable{cursor:pointer;}#mermaid-svg-6NnKgRXmDZIxV4Ta .arrowheadPath{fill:#333333;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edgePath .path{stroke:#666;stroke-width:1.5px;}#mermaid-svg-6NnKgRXmDZIxV4Ta .flowchart-link{stroke:#666;fill:none;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edgeLabel{background-color:white;text-align:center;}#mermaid-svg-6NnKgRXmDZIxV4Ta .edgeLabel rect{opacity:0.5;background-color:white;fill:white;}#mermaid-svg-6NnKgRXmDZIxV4Ta .cluster rect{fill:hsl(210,66.6666666667%,95%);stroke:#26a;stroke-width:1px;}#mermaid-svg-6NnKgRXmDZIxV4Ta .cluster text{fill:#333;}#mermaid-svg-6NnKgRXmDZIxV4Ta .cluster span{color:#333;}#mermaid-svg-6NnKgRXmDZIxV4Ta div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(-160,0%,93.3333333333%);border:1px solid #26a;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-6NnKgRXmDZIxV4Ta:root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}#mermaid-svg-6NnKgRXmDZIxV4Ta flowchart{fill:apa;}</style><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-expr LE-add" id="L-expr-add" style="opacity: 1;"><path class="path" d="M128.078125,59.875L128.078125,84.875L128.078125,109.875" marker-end="url(https://stackedit.io/app#arrowhead31)" style="fill:none"></path><defs><marker id="arrowhead31" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-add LE-one" id="L-add-one" style="opacity: 1;"><path class="path" d="M144.5956974667795,149.7519474667795L176.4375,181.59375L176.4375,206.59375" marker-end="url(https://stackedit.io/app#arrowhead32)" style="fill:none"></path><defs><marker id="arrowhead32" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-add LE-mul" id="L-add-mul" style="opacity: 1;"><path class="path" d="M111.56055253322049,149.7519474667795L79.71875,181.59375L79.71875,206.59375" marker-end="url(https://stackedit.io/app#arrowhead33)" style="fill:none"></path><defs><marker id="arrowhead33" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-mul LE-four" id="L-mul-four" style="opacity: 1;"><path class="path" d="M63.20117753322049,246.4706974667795L31.359375,278.3125L31.359375,303.3125" marker-end="url(https://stackedit.io/app#arrowhead34)" style="fill:none"></path><defs><marker id="arrowhead34" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-mul LE-eight" id="L-mul-eight" style="opacity: 1;"><path class="path" d="M96.23632246677951,246.4706974667795L128.078125,278.3125L128.078125,303.3125" marker-end="url(https://stackedit.io/app#arrowhead35)" style="fill:none"></path><defs><marker id="arrowhead35" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-expr-add" class="edgeLabel L-LS-expr' L-LE-add"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-add-one" class="edgeLabel L-LS-add' L-LE-one"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-add-mul" class="edgeLabel L-LS-add' L-LE-mul"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-mul-four" class="edgeLabel L-LS-mul' L-LE-four"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-mul-eight" class="edgeLabel L-LS-mul' L-LE-eight"></span></div></foreignObject></g></g></g><g class="nodes"><g class="node default" id="flowchart-expr-208" transform="translate(128.078125,33.9375)" style="opacity: 1;"><circle x="-25.9375" y="-23.359375" r="25.9375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-15.9375,-13.359375)"><foreignObject width="31.875" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">expr</div></foreignObject></g></g></g><g class="node default" id="flowchart-add-209" transform="translate(128.078125,133.234375)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">+</div></foreignObject></g></g></g><g class="node default" id="flowchart-mul-210" transform="translate(79.71875,229.953125)" style="opacity: 1;"><circle x="-12.9375" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-2.9375,-13.359375)"><foreignObject width="5.875" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">*</div></foreignObject></g></g></g><g class="node default" id="flowchart-one-211" transform="translate(176.4375,229.953125)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">1</div></foreignObject></g></g></g><g class="node default" id="flowchart-four-212" transform="translate(31.359375,326.671875)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">4</div></foreignObject></g></g></g><g class="node default" id="flowchart-eight-213" transform="translate(128.078125,326.671875)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">8</div></foreignObject></g></g></g></g></g></g></svg></pre>
<p>and the second one is</p>
<pre class=" language-mermaid"><svg id="mermaid-svg-5JehmVT5RVR4iYOy" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="358.03125" style="max-width: 207.796875px;" viewBox="0 0 207.796875 358.03125"><style>#mermaid-svg-5JehmVT5RVR4iYOy{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#000000;}#mermaid-svg-5JehmVT5RVR4iYOy .error-icon{fill:#552222;}#mermaid-svg-5JehmVT5RVR4iYOy .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-5JehmVT5RVR4iYOy .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-5JehmVT5RVR4iYOy .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-5JehmVT5RVR4iYOy .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-5JehmVT5RVR4iYOy .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-5JehmVT5RVR4iYOy .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-5JehmVT5RVR4iYOy .marker{fill:#666;stroke:#666;}#mermaid-svg-5JehmVT5RVR4iYOy .marker.cross{stroke:#666;}#mermaid-svg-5JehmVT5RVR4iYOy svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-5JehmVT5RVR4iYOy .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#000000;}#mermaid-svg-5JehmVT5RVR4iYOy .cluster-label text{fill:#333;}#mermaid-svg-5JehmVT5RVR4iYOy .cluster-label span{color:#333;}#mermaid-svg-5JehmVT5RVR4iYOy .label text,#mermaid-svg-5JehmVT5RVR4iYOy span{fill:#000000;color:#000000;}#mermaid-svg-5JehmVT5RVR4iYOy .node rect,#mermaid-svg-5JehmVT5RVR4iYOy .node circle,#mermaid-svg-5JehmVT5RVR4iYOy .node ellipse,#mermaid-svg-5JehmVT5RVR4iYOy .node polygon,#mermaid-svg-5JehmVT5RVR4iYOy .node path{fill:#eee;stroke:#999;stroke-width:1px;}#mermaid-svg-5JehmVT5RVR4iYOy .node .label{text-align:center;}#mermaid-svg-5JehmVT5RVR4iYOy .node.clickable{cursor:pointer;}#mermaid-svg-5JehmVT5RVR4iYOy .arrowheadPath{fill:#333333;}#mermaid-svg-5JehmVT5RVR4iYOy .edgePath .path{stroke:#666;stroke-width:1.5px;}#mermaid-svg-5JehmVT5RVR4iYOy .flowchart-link{stroke:#666;fill:none;}#mermaid-svg-5JehmVT5RVR4iYOy .edgeLabel{background-color:white;text-align:center;}#mermaid-svg-5JehmVT5RVR4iYOy .edgeLabel rect{opacity:0.5;background-color:white;fill:white;}#mermaid-svg-5JehmVT5RVR4iYOy .cluster rect{fill:hsl(210,66.6666666667%,95%);stroke:#26a;stroke-width:1px;}#mermaid-svg-5JehmVT5RVR4iYOy .cluster text{fill:#333;}#mermaid-svg-5JehmVT5RVR4iYOy .cluster span{color:#333;}#mermaid-svg-5JehmVT5RVR4iYOy div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(-160,0%,93.3333333333%);border:1px solid #26a;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-5JehmVT5RVR4iYOy:root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}#mermaid-svg-5JehmVT5RVR4iYOy flowchart{fill:apa;}</style><g><g class="output"><g class="clusters"></g><g class="edgePaths"><g class="edgePath LS-expr LE-mul" id="L-expr-mul" style="opacity: 1;"><path class="path" d="M128.078125,59.875L128.078125,84.875L128.078125,109.875" marker-end="url(https://stackedit.io/app#arrowhead36)" style="fill:none"></path><defs><marker id="arrowhead36" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-mul LE-add" id="L-mul-add" style="opacity: 1;"><path class="path" d="M111.56055253322049,149.7519474667795L79.71875,181.59375L79.71875,206.59375" marker-end="url(https://stackedit.io/app#arrowhead37)" style="fill:none"></path><defs><marker id="arrowhead37" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-add LE-one" id="L-add-one" style="opacity: 1;"><path class="path" d="M63.20117753322049,246.4706974667795L31.359375,278.3125L31.359375,303.3125" marker-end="url(https://stackedit.io/app#arrowhead38)" style="fill:none"></path><defs><marker id="arrowhead38" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-add LE-four" id="L-add-four" style="opacity: 1;"><path class="path" d="M96.23632246677951,246.4706974667795L128.078125,278.3125L128.078125,303.3125" marker-end="url(https://stackedit.io/app#arrowhead39)" style="fill:none"></path><defs><marker id="arrowhead39" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g><g class="edgePath LS-mul LE-eight" id="L-mul-eight" style="opacity: 1;"><path class="path" d="M144.5956974667795,149.7519474667795L176.4375,181.59375L176.4375,206.59375" marker-end="url(https://stackedit.io/app#arrowhead40)" style="fill:none"></path><defs><marker id="arrowhead40" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-expr-mul" class="edgeLabel L-LS-expr' L-LE-mul"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-mul-add" class="edgeLabel L-LS-mul' L-LE-add"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-add-one" class="edgeLabel L-LS-add' L-LE-one"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-add-four" class="edgeLabel L-LS-add' L-LE-four"></span></div></foreignObject></g></g><g class="edgeLabel" transform="" style="opacity: 1;"><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-mul-eight" class="edgeLabel L-LS-mul' L-LE-eight"></span></div></foreignObject></g></g></g><g class="nodes"><g class="node default" id="flowchart-expr-240" transform="translate(128.078125,33.9375)" style="opacity: 1;"><circle x="-25.9375" y="-23.359375" r="25.9375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-15.9375,-13.359375)"><foreignObject width="31.875" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">expr</div></foreignObject></g></g></g><g class="node default" id="flowchart-add-241" transform="translate(79.71875,229.953125)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">+</div></foreignObject></g></g></g><g class="node default" id="flowchart-mul-242" transform="translate(128.078125,133.234375)" style="opacity: 1;"><circle x="-12.9375" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-2.9375,-13.359375)"><foreignObject width="5.875" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">*</div></foreignObject></g></g></g><g class="node default" id="flowchart-one-243" transform="translate(31.359375,326.671875)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">1</div></foreignObject></g></g></g><g class="node default" id="flowchart-four-244" transform="translate(128.078125,326.671875)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">4</div></foreignObject></g></g></g><g class="node default" id="flowchart-eight-245" transform="translate(176.4375,229.953125)" style="opacity: 1;"><circle x="-14.197916984558105" y="-23.359375" r="23.359375" class="label-container"></circle><g class="label" transform="translate(0,0)"><g transform="translate(-4.1979169845581055,-13.359375)"><foreignObject width="8.395833969116211" height="26.71875"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">8</div></foreignObject></g></g></g></g></g></g></svg></pre>
<p>There are different techniques to remove ambiguities from context-free grammar. Here are some common methods:</p>
<ol>
<li>
<p>Left-Factoring: This method involves breaking the rules into smaller pieces that do not overlap, thus eliminating ambiguity. For example, we can factor the rule <code>expr + expr</code> into <code>expr + term</code> and <code>term</code>, where <code>term</code> represents any expression that is not a sum of terms.</p>
</li>
<li>
<p>Left-Recursion Removal: This method involves removing left-recursion from the rules. For example, we can rewrite the rule <code>expr -&gt; expr + term</code> as <code>expr -&gt; term expr</code>, and <code>expr' -&gt; + term expr | ε</code>.</p>
</li>
<li>
<p>Operator Precedence Parsing: This method involves specifying the operator precedence and associativity rules explicitly in the grammar so that the parser can resolve ambiguities based on these rules.</p>
</li>
<li>
<p>Parsing Tables: This method involves constructing a table that specifies the actions to be taken by the parser based on the input token and the current state of the parsing stack.</p>
</li>
</ol>
<p>These are just a few examples of techniques for removing ambiguities from context-free grammar. The choice of method depends on the specific grammar and the requirements of the application.</p>
<h2 id="precedence-constraint">Precedence Constraint</h2>
<p>The precedence constraint is implemented using the following rules-</p>
<ul>
<li>The level at which the production is present defines the operator’s priority.</li>
<li>The higher the level of production, the lower the operator’s priority.</li>
<li>The lower the level of production, the higher the operator’s priority.</li>
</ul>
<h2 id="associativity-constraint">Associativity Constraint</h2>
<p>The associativity constraint is implemented using the following rules-</p>
<ul>
<li>If the operator is left-associative, induce left recursion in its production.</li>
<li>If the operator is right-associative, induce the right recursion in its production.</li>
</ul>
<p>![Image]</p>
<blockquote>
<p>Removing Ambiguity in Grammar</p>
</blockquote>
<div class="alert-info">
</div><p>Production of the form <code>N → α*N</code> is <em>right recursive</em> because the recursive reference to nonterminal <em>N</em> is at the right end of the right-hand side. For Example, production <code>E → T + E</code> is right recursive, indicating that + is <em>right-associative</em> (done from right to left).</p>

<hr>
<div class="alert-info">
</div><p>Similarly, a production of the form <code>N* → Nα</code> is <em>left recursive</em>. Left-recursive rule <code>T → T * F</code> indicates that <code>*</code> is <em>left-associative</em> (done from left to right).</p>

<hr>
<p>Now we know how to remove the ambiguity in the grammar so Let’s rewrite our grammar again by applying the above principle to our grammar; we want <code>*</code> always to have higher precedence than <code>+</code>. For a grammar that does that, see Example. We usually want a left-associative expression within a single precedence level and, therefore, a left-associative grammar.</p>
<p><img src="./chapter-03/desc-gram-sem.png" alt="Image"></p>
<ol>
<li><code>expr + term</code> is different from <code>term + expr</code>. It controls<br>
associativity (left or right)</li>
<li>Multiplication is a lower rule, Forces multiplication to occur lower<br>
in the parse tree, thus giving it higher precedence than addition.</li>
</ol>
<blockquote>
<p>Let’s understand the difference between <code>expr+term</code> and <code>term+expr</code> with<br>
parse tree.</p>
</blockquote>
<p><code>expr -&gt; expr + term</code>, (left recursion of expr), it causes left associativity</p>
<p>Let’s assume you want to parse 1+2+3 by using the above grammar.</p>
<p><img src="./chapter-03/bd163583-61b0-4ebe-a9b8-5fa32b24cfc6_smallRaw.png" alt="Image"></p>
<pre class=" language-csharp"><code class="prism  language-csharp">
expr<span class="token operator">-</span><span class="token operator">&gt;</span>expr<span class="token operator">+</span>term
expr <span class="token operator">-</span><span class="token operator">&gt;</span> term <span class="token operator">+</span> expr # <span class="token punctuation">(</span>right recursion of expr<span class="token punctuation">)</span><span class="token punctuation">,</span> it causes right associativity

</code></pre>
<p><img src="./chapter-03/f61cb50b-913e-46dc-88bb-b86fbf3f29a8_smallRaw.png" alt="Image"></p>
<pre class=" language-csharp"><code class="prism  language-csharp">expr<span class="token operator">-</span><span class="token operator">&gt;</span>term<span class="token operator">+</span>expr
</code></pre>
<h2 id="cfg-for-boolean">CFG for Boolean</h2>
<p>Convert the following ambiguous grammar into unambiguous grammar-</p>
<pre class=" language-csharp"><code class="prism  language-csharp">be<span class="token punctuation">:</span> be or be
    <span class="token operator">|</span> be and be
    <span class="token operator">|</span> not be
    <span class="token operator">|</span> T
    <span class="token operator">|</span> F

</code></pre>
<div class="alert-info">
</div><p>Where <strong>be</strong> represents Boolean expression, T represents True, and F represents False.</p>

<p>One way to remove ambiguity is to rewrite the grammar using operator precedence rules. For boolean expressions, the order of precedence is usually “not” &gt; “and” &gt; “or”, so we can modify the grammar accordingly.</p>
<ul>
<li>We have-Given grammar consisting of the following operators-<code>OR</code>,<br>
<code>AND</code>, <code>NOT</code></li>
<li>Given grammar consists of the following operands-<code>T</code>, <code>F</code></li>
<li>The priority order is-(<code>T</code>, <code>F</code>) <code>&gt;</code> <code>not</code>  and <code>or</code></li>
</ul>
<p>where-</p>
<ul>
<li><strong>AND</strong> the operator is left-associative</li>
<li><strong>OR</strong> operator is left-associative</li>
</ul>
<p>Using the precedence and associativity rules, we write the corresponding<br>
unambiguous grammar as-.</p>
<pre class=" language-csharp"><code class="prism  language-csharp">be<span class="token operator">-</span><span class="token operator">&gt;</span>be or P <span class="token operator">|</span> P
P<span class="token operator">-</span><span class="token operator">&gt;</span>P and Q <span class="token operator">|</span> Q
Q<span class="token operator">-</span><span class="token operator">&gt;</span>not Q <span class="token operator">|</span> R
R<span class="token operator">-</span><span class="token operator">&gt;</span>T <span class="token operator">|</span> F

</code></pre>
<h2 id="dangling-else-problem">Dangling else problem</h2>
<blockquote>
<p>Many grammars are ambiguous by nature. The “dangling else” problem is a common example: when if-then-else statements nest, it’s unclear which “if” owns the “else” clause. The most common technique is to link the “else” to the closest object. If you want to learn about dangling if<br>
else problem visit the <a href="https://en.wikipedia.org/wiki/Dangling_else">Wikipedia</a></p>
</blockquote>
<p>This is the problem of determining, in a series of if terminating with an else, to which the else is referring. The ambiguous grammar is:</p>
<pre class=" language-csharp"><code class="prism  language-csharp">    stmt<span class="token punctuation">:</span> <span class="token string">'if'</span> expr <span class="token string">'then'</span> stmt <span class="token string">'else'</span> <span class="token function">stmt</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>
            <span class="token operator">|</span> <span class="token string">'if'</span> expr <span class="token string">'then'</span> <span class="token function">stmt</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span>
            <span class="token operator">|</span> ID <span class="token string">'='</span> expr <span class="token punctuation">;</span>

</code></pre>
<p>Now, let’s consider the following code snippet:</p>
<pre class=" language-csharp"><code class="prism  language-csharp">
`<span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> then <span class="token keyword">if</span> y <span class="token operator">&lt;</span> <span class="token number">5</span> then z <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">else</span> z <span class="token operator">=</span> <span class="token number">2</span>` 
</code></pre>
<p>In this case, there are two possible interpretations of this code based on the grammar. One interpretation is that the <code>else</code> clause is associated with the inner <code>if</code> statement, and the other interpretation is that it is associated with the outer <code>if</code> statement.</p>
<ul>
<li>Using the production <code>(a)</code> of the grammar, we get the parse tree shown below:</li>
</ul>
<pre><code>          if
         /  \
        /    \
       &lt;     stmt
      / \
     x   \
         if
        /  \
       /    \
      &lt;     stmt
     / \
    y   \
         =
        / \
       z   1` 
</code></pre>
<ul>
<li>Using the production <code>(b)</code> of the grammar, we get the parse tree shown below:</li>
</ul>
<pre><code>          if
         /  \
        /    \
       &lt;     stmt
      / \
     x   \
         if
        /  \
       /    \
      &lt;     stmt
     / \
    y   \
         =
        / \
       z   2` 
</code></pre>
<p>As you can see, the two parse trees differ in the way the <code>else</code> clause is associated with the <code>if</code> statements.</p>
<p>To remove the ambiguity, we need to modify the grammar to ensure that the <code>else</code> clause is always associated with the nearest <code>if</code> statement. One way to do this is to use the following grammar:</p>
<blockquote>
<p>Solution-I</p>
</blockquote>
<pre class=" language-csharp"><code class="prism  language-csharp">
stmt<span class="token punctuation">:</span> <span class="token string">'if'</span> expr <span class="token string">'then'</span> <span class="token function">stmt</span> <span class="token punctuation">(</span><span class="token string">'else'</span> stmt<span class="token punctuation">)</span><span class="token operator">?</span>
    <span class="token operator">|</span> ID <span class="token string">'='</span> expr <span class="token punctuation">;</span>` 
</code></pre>
<p>In this grammar, the <code>else</code> clause is made optional, and the use of parentheses in the production <code>(a)</code> ensures that the <code>else</code> clause is associated with the nearest <code>if</code> statement. With this modified grammar, the code snippet above would be parsed as follows:</p>
<pre><code>
         if
         /  \
        /    \
       &lt;     if
      / \   /  \
     x   &lt; y    =
         / \   / \
        z   1 z   2
</code></pre>
<blockquote>
<p>Solution-2</p>
</blockquote>
<pre class=" language-csharp"><code class="prism  language-csharp">    stmt<span class="token punctuation">:</span>   <span class="token string">'if'</span> expr <span class="token string">'then'</span> <span class="token function">stmt</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span>
            <span class="token operator">|</span><span class="token string">'if'</span> expr <span class="token string">'then'</span> stmt <span class="token string">'else'</span> <span class="token function">stmt</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>   
            <span class="token operator">|</span> ID <span class="token string">'='</span> expr <span class="token punctuation">;</span>
</code></pre>
<h2 id="things-to-remember-when-writing-antlr-grammar-for-lexer-and-parser">Things to remember when writing ANTLR grammar for lexer and parser</h2>
<p>When writing an ANTLR grammar for a lexer and parser, there are several important things to remember:</p>
<ol>
<li>
<p>Understand the language you’re parsing: Before starting to write a grammar, you need to have a good understanding of the language you’re trying to parse. This includes understanding the syntax, semantics, and any quirks or edge cases that might exist.</p>
</li>
<li>
<p>Keeping the lexer and parser separate: In your grammar, you would define your lexer rules to match individual tokens such as numbers, operators, and parentheses. For example, the lexer rule for matching a number could look like this:</p>
</li>
</ol>
<pre class=" language-cshar"><code class="prism [p language-cshar">NUMBER : DIGIT+ ( '.' DIGIT+ )?;
fragment DIGIT : [0-9];
</code></pre>
<p>In this rule, we define <code>NUMBER</code> as a token that consists of one or more digits, optionally followed by a decimal point and one or more digits. We also define a fragment rule <code>DIGIT</code> that matches a single digit.</p>
<p>Once the lexer has produced the tokens, the parser will consume them to build a parse tree that represents the structure of the arithmetic expression.<br>
3. Using clear and descriptive names: In your grammar, you should use clear and descriptive names for your tokens and rules to make the grammar easier to read and maintain. For example, you could define a rule for parsing an arithmetic expression as follows:</p>
<pre class=" language-csharp"><code class="prism  language-csharp">expr <span class="token punctuation">:</span> <span class="token function">term</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token string">'+'</span> <span class="token operator">|</span> <span class="token string">'-'</span> <span class="token punctuation">)</span> term <span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">;</span>
</code></pre>
<p>Here, we define <code>expr</code> as a nonterminal symbol that represents an arithmetic expression. The rule says that an expression consists of one or more terms separated by either a plus or minus operator.<br>
4.  Keeping it simple: It’s important to keep your grammar simple and focused on the essentials of the language you’re parsing. For example, you could choose to only support addition and subtraction in your arithmetic expressions, and leave out more complex operations like multiplication and division.</p>
<ol start="5">
<li>
<p>Testing your grammar: Once you’ve written your grammar, you should test it thoroughly with a variety of inputs to ensure that it works correctly in all cases. For example, you could test your grammar with inputs like <code>3 + 4 - 2</code>, <code>(2 + 3) * 4</code>, and <code>5 / (2 - 1)</code> to make sure it correctly handles parentheses and the order of operations.</p>
</li>
<li>
<p>Documenting your grammar: Finally, you should document your grammar with comments and explanations of each rule and token. For example, you could add comments like this to your grammar:</p>
</li>
</ol>
<pre class=" language-csharp"><code class="prism  language-csharp">`<span class="token comment">// Matches a number, with an optional decimal point and fractional part</span>
NUMBER <span class="token punctuation">:</span> DIGIT<span class="token operator">+</span> <span class="token punctuation">(</span> <span class="token string">'.'</span> DIGIT<span class="token operator">+</span> <span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span>

<span class="token comment">// Matches a single digit</span>
fragment DIGIT <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Matches an arithmetic expression, consisting of one or more terms separated by plus or minus</span>
expr <span class="token punctuation">:</span> <span class="token function">term</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token string">'+'</span> <span class="token operator">|</span> <span class="token string">'-'</span> <span class="token punctuation">)</span> term <span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">;</span>
</code></pre>


</div>